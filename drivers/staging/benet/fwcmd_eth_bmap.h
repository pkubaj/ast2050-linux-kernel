/*
 * Copyright (C) 2005 - 2008 ServerEngines
 * All rights reserved.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License version 2
 * as published by the Free Software Foundation.  The full GNU General
 * Public License is included in this distribution in the file called COPYING.
 *
 * Contact Information:
 * linux-drivers@serverengines.com
 *
 * ServerEngines
 * 209 N. Fair Oaks Ave
 * Sunnyvale, CA 94085
 */
/*
 * Autogenerated by srcgen version: 0127
 */
#ifndef __fwcmd_eth_bmap_h__
#define __fwcmd_eth_bmap_h__
#include "fwcmd_hdr_bmap.h"
#include "fwcmd_types_bmap.h"

struct MIB_ETH_STATISTICS_PARAMS_IN {
	u32 rsvd0;
} __packed;

struct BE_RXF_STATS {
	u32 p0recvdtotalbytesLSD;	/* DWORD 0 */
	u32 p0recvdtotalbytesMSD;	/* DWORD 1 */
	u32 p0recvdtotalframes;	/* DWORD 2 */
	u32 p0recvdunicastframes;	/* DWORD 3 */
	u32 p0recvdmulticastframes;	/* DWORD 4 */
	u32 p0recvdbroadcastframes;	/* DWORD 5 */
	u32 p0crcerrors;	/* DWORD 6 */
	u32 p0alignmentsymerrs;	/* DWORD 7 */
	u32 p0pauseframesrecvd;	/* DWORD 8 */
	u32 p0controlframesrecvd;	/* DWORD 9 */
	u32 p0inrangelenerrors;	/* DWORD 10 */
	u32 p0outrangeerrors;	/* DWORD 11 */
	u32 p0frametoolongerrors;	/* DWORD 12 */
	u32 p0droppedaddressmatch;	/* DWORD 13 */
	u32 p0droppedvlanmismatch;	/* DWORD 14 */
	u32 p0ipdroppedtoosmall;	/* DWORD 15 */
	u32 p0ipdroppedtooshort;	/* DWORD 16 */
	u32 p0ipdroppedhdrtoosmall;	/* DWORD 17 */
	u32 p0tcpdroppedlen;	/* DWORD 18 */
	u32 p0droppedrunt;	/* DWORD 19 */
	u32 p0recvd64;		/* DWORD 20 */
	u32 p0recvd65_127;	/* DWORD 21 */
	u32 p0recvd128_256;	/* DWORD 22 */
	u32 p0recvd256_511;	/* DWORD 23 */
	u32 p0recvd512_1023;	/* DWORD 24 */
	u32 p0recvd1518_1522;	/* DWORD 25 */
	u32 p0recvd1522_2047;	/* DWORD 26 */
	u32 p0recvd2048_4095;	/* DWORD 27 */
	u32 p0recvd4096_8191;	/* DWORD 28 */
	u32 p0recvd8192_9216;	/* DWORD 29 */
	u32 p0rcvdipcksmerrs;	/* DWORD 30 */
	u32 p0recvdtcpcksmerrs;	/* DWORD 31 */
	u32 p0recvdudpcksmerrs;	/* DWORD 32 */
	u32 p0recvdnonrsspackets;	/* DWORD 33 */
	u32 p0recvdippackets;	/* DWORD 34 */
	u32 p0recvdchute1packets;	/* DWORD 35 */
	u32 p0recvdchute2packets;	/* DWORD 36 */
	u32 p0recvdchute3packets;	/* DWORD 37 */
	u32 p0recvdipsecpackets;	/* DWORD 38 */
	u32 p0recvdmanagementpackets;	/* DWORD 39 */
	u32 p0xmitbyteslsd;	/* DWORD 40 */
	u32 p0xmitbytesmsd;	/* DWORD 41 */
	u32 p0xmitunicastframes;	/* DWORD 42 */
	u32 p0xmitmulticastframes;	/* DWORD 43 */
	u32 p0xmitbroadcastframes;	/* DWORD 44 */
	u32 p0xmitpauseframes;	/* DWORD 45 */
	u32 p0xmitcontrolframes;	/* DWORD 46 */
	u32 p0xmit64;		/* DWORD 47 */
	u32 p0xmit65_127;	/* DWORD 48 */
	u32 p0xmit128_256;	/* DWORD 49 */
	u32 p0xmit256_511;	/* DWORD 50 */
	u32 p0xmit512_1023;	/* DWORD 51 */
	u32 p0xmit1518_1522;	/* DWORD 52 */
	u32 p0xmit1522_2047;	/* DWORD 53 */
	u32 p0xmit2048_4095;	/* DWORD 54 */
	u32 p0xmit4096_8191;	/* DWORD 55 */
	u32 p0xmit8192_9216;	/* DWORD 56 */
	u32 p0rxfifooverflowdropped;	/* DWORD 57 */
	u32 p0ipseclookupfaileddropped;	/* DWORD 58 */
	u32 p1recvdtotalbytesLSD;	/* DWORD 59 */
	u32 p1recvdtotalbytesMSD;	/* DWORD 60 */
	u32 p1recvdtotalframes;	/* DWORD 61 */
	u32 p1recvdunicastframes;	/* DWORD 62 */
	u32 p1recvdmulticastframes;	/* DWORD 63 */
	u32 p1recvdbroadcastframes;	/* DWORD 64 */
	u32 p1crcerrors;	/* DWORD 65 */
	u32 p1alignmentsymerrs;	/* DWORD 66 */
	u32 p1pauseframesrecvd;	/* DWORD 67 */
	u32 p1controlframesrecvd;	/* DWORD 68 */
	u32 p1inrangelenerrors;	/* DWORD 69 */
	u32 p1outrangeerrors;	/* DWORD 70 */
	u32 p1frametoolongerrors;	/* DWORD 71 */
	u32 p1droppedaddressmatch;	/* DWORD 72 */
	u32 p1droppedvlanmismatch;	/* DWORD 73 */
	u32 p1ipdroppedtoosmall;	/* DWORD 74 */
	u32 p1ipdroppedtooshort;	/* DWORD 75 */
	u32 p1ipdroppedhdrtoosmall;	/* DWORD 76 */
	u32 p1tcpdroppedlen;	/* DWORD 77 */
	u32 p1droppedrunt;	/* DWORD 78 */
	u32 p1recvd64;		/* DWORD 79 */
	u32 p1recvd65_127;	/* DWORD 80 */
	u32 p1recvd128_256;	/* DWORD 81 */
	u32 p1recvd256_511;	/* DWORD 82 */
	u32 p1recvd512_1023;	/* DWORD 83 */
	u32 p1recvd1518_1522;	/* DWORD 84 */
	u32 p1recvd1522_2047;	/* DWORD 85 */
	u32 p1recvd2048_4095;	/* DWORD 86 */
	u32 p1recvd4096_8191;	/* DWORD 87 */
	u32 p1recvd8192_9216;	/* DWORD 88 */
	u32 p1rcvdipcksmerrs;	/* DWORD 89 */
	u32 p1recvdtcpcksmerrs;	/* DWORD 90 */
	u32 p1recvdudpcksmerrs;	/* DWORD 91 */
	u32 p1recvdnonrsspackets;	/* DWORD 92 */
	u32 p1recvdippackets;	/* DWORD 93 */
	u32 p1recvdchute1packets;	/* DWORD 94 */
	u32 p1recvdchute2packets;	/* DWORD 95 */
	u32 p1recvdchute3packets;	/* DWORD 96 */
	u32 p1recvdipsecpackets;	/* DWORD 97 */
	u32 p1recvdmanagementpackets;	/* DWORD 98 */
	u32 p1xmitbyteslsd;	/* DWORD 99 */
	u32 p1xmitbytesmsd;	/* DWORD 100 */
	u32 p1xmitunicastframes;	/* DWORD 101 */
	u32 p1xmitmulticastframes;	/* DWORD 102 */
	u32 p1xmitbroadcastframes;	/* DWORD 103 */
	u32 p1xmitpauseframes;	/* DWORD 104 */
	u32 p1xmitcontrolframes;	/* DWORD 105 */
	u32 p1xmit64;		/* DWORD 106 */
	u32 p1xmit65_127;	/* DWORD 107 */
	u32 p1xmit128_256;	/* DWORD 108 */
	u32 p1xmit256_511;	/* DWORD 109 */
	u32 p1xmit512_1023;	/* DWORD 110 */
	u32 p1xmit1518_1522;	/* DWORD 111 */
	u32 p1xmit1522_2047;	/* DWORD 112 */
	u32 p1xmit2048_4095;	/* DWORD 113 */
	u32 p1xmit4096_8191;	/* DWORD 114 */
	u32 p1xmit8192_9216;	/* DWORD 115 */
	u32 p1rxfifooverflowdropped;	/* DWORD 116 */
	u32 p1ipseclookupfaileddropped;	/* DWORD 117 */
	u32 pxdroppednopbuf;	/* DWORD 118 */
	u32 pxdroppednotxpb;	/* DWORD 119 */
	u32 pxdroppednoipsecbuf;	/* DWORD 120 */
	u32 pxdroppednoerxdescr;	/* DWORD 121 */
	u32 pxdroppednotpredescr;	/* DWORD 122 */
	u32 pxrecvdmanagementportpackets;	/* DWORD 123 */
	u32 pxrecvdmanagementportbytes;	/* DWORD 124 */
	u32 pxrecvdmanagementportpauseframes;	/* DWORD 125 */
	u32 pxrecvdmanagementporterrors;	/* DWORD 126 */
	u32 pxxmitmanagementportpackets;	/* DWORD 127 */
	u32 pxxmitmanagementportbytes;	/* DWORD 128 */
	u32 pxxmitmanagementportpause;	/* DWORD 129 */
	u32 pxxmitmanagementportrxfifooverflow;	/* DWORD 130 */
	u32 pxrecvdipsecipcksmerrs;	/* DWORD 131 */
	u32 pxrecvdtcpsecipcksmerrs;	/* DWORD 132 */
	u32 pxrecvdudpsecipcksmerrs;	/* DWORD 133 */
	u32 pxipsecrunt;	/* DWORD 134 */
	u32 pxipsecaddressmismatchdropped;	/* DWORD 135 */
	u32 pxipsecrxfifooverflowdropped;	/* DWORD 136 */
	u32 pxipsecframestoolong;	/* DWORD 137 */
	u32 pxipsectotalipframes;	/* DWORD 138 */
	u32 pxipseciptoosmall;	/* DWORD 139 */
	u32 pxipseciptooshort;	/* DWORD 140 */
	u32 pxipseciphdrtoosmall;	/* DWORD 141 */
	u32 pxipsectcphdrbad;	/* DWORD 142 */
	u32 pxrecvdipsecchute1;	/* DWORD 143 */
	u32 pxrecvdipsecchute2;	/* DWORD 144 */
	u32 pxrecvdipsecchute3;	/* DWORD 145 */
	u32 pxdropped7frags;	/* DWORD 146 */
	u32 pxdroppedfrags;	/* DWORD 147 */
	u32 pxdroppedinvalidfragring;	/* DWORD 148 */
	u32 pxnumforwardedpackets;	/* DWORD 149 */
} __packed;

union MIB_ETH_STATISTICS_PARAMS {
	struct MIB_ETH_STATISTICS_PARAMS_IN request;
	struct BE_RXF_STATS response;
} __packed;

/*
 *  Query ethernet statistics. All domains may issue this command. The
 *  host domain drivers  may optionally reset internal statistic counters
 *  with a query.
 */
struct FWCMD_ETH_GET_STATISTICS {
	union FWCMD_HEADER header;
	union MIB_ETH_STATISTICS_PARAMS params;
} __packed;


struct FWCMD_ETH_ANON_175_REQUEST {
	u8 port0_promiscuous;
	u8 port1_promiscuous;
	u16 rsvd0;
} __packed;

struct FWCMD_ETH_ANON_176_RESPONSE {
	u32 rsvd0;
} __packed;

union FWCMD_ETH_ANON_174_PARAMS {
	struct FWCMD_ETH_ANON_175_REQUEST request;
	struct FWCMD_ETH_ANON_176_RESPONSE response;
} __packed;

/* Enables/Disables promiscuous ethernet receive mode.  */
struct FWCMD_ETH_PROMISCUOUS {
	union FWCMD_HEADER header;
	union FWCMD_ETH_ANON_174_PARAMS params;
} __packed;

struct FWCMD_ETH_ANON_178_REQUEST {
	u32 new_fragsize_log2;
} __packed;

struct FWCMD_ETH_ANON_179_RESPONSE {
	u32 actual_fragsize_log2;
} __packed;

union FWCMD_ETH_ANON_177_PARAMS {
	struct FWCMD_ETH_ANON_178_REQUEST request;
	struct FWCMD_ETH_ANON_179_RESPONSE response;
} __packed;

/*
 *  Sets the Ethernet RX fragment size. Only host (domain 0) networking
 *  drivers may issue  this command.  This call will fail for non-host
 *  protection domains. In this situation the  MCC CQ status will indicate
 *  a failure due to insufficient priviledges. The response  should be
 *  ignored, and the driver should use the FWCMD_ETH_GET_FRAG_SIZE to
 *  query the  existing ethernet receive fragment size. It must use this
 *  fragment size for all  fragments in the ethernet receive ring.  If
 *  the command succeeds, the driver must use the  frag size indicated
 *  in the command response since the requested frag size may not be  applied
 *  until the next reboot. When the requested fragsize matches the response
 *   fragsize, this indicates the request was applied immediately.
 */
struct FWCMD_ETH_SET_RX_FRAG_SIZE {
	union FWCMD_HEADER header;
	union FWCMD_ETH_ANON_177_PARAMS params;
} __packed;

struct FWCMD_ETH_ANON_181_REQUEST {
	u32 rsvd0;
} __packed;

struct FWCMD_ETH_ANON_182_RESPONSE {
	u32 actual_fragsize_log2;
} __packed;

union FWCMD_ETH_ANON_180_PARAMS {
	struct FWCMD_ETH_ANON_181_REQUEST request;
	struct FWCMD_ETH_ANON_182_RESPONSE response;
} __packed;

/*
 *  Queries the Ethernet RX fragment size. All domains may issue this
 *  command.  The driver  should call this command to determine the minimum
 *  required fragment size for the ethernet  RX ring buffers. Drivers
 *  may choose to use a larger size for each fragment buffer, but  BladeEngine
 *  will use up to the configured minimum required fragsize in each ethernet
 *   receive fragment buffer. For example, if the ethernet receive fragment
 *  size is  configured to 4kB, and a driver uses 8kB fragments, a 6kB
 *  ethernet packet received by  BladeEngine will be split accross two
 *  of the driver's receive framgents (4kB in one  fragment buffer, and
 *  2kB in the subsequent fragment buffer).
 */
struct FWCMD_ETH_GET_RX_FRAG_SIZE {
	union FWCMD_HEADER header;
	union FWCMD_ETH_ANON_180_PARAMS params;
} __packed;

#endif /* __fwcmd_eth_bmap_h__ */
